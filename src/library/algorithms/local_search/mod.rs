//! This module provides the actual local search algorithms of this project.

use std::fs::{
	create_dir_all,
	File,
};
use std::hash::Hash;
use std::io::{
	BufRead,
	BufReader,
	Write,
};
use std::path::{Path,};
use bitmaps::{
	Bits,
	BitsImpl,
};
use log::{
	debug,
	info,
};
use rayon::prelude::*;
use crate::algorithms::local_search::algorithms::AlgorithmRunner;
use crate::algorithms::local_search::regularizer::Regularizer;
use crate::algorithms::local_search::run_config::RunConfig;
use crate::algorithms::local_search::state::State;
use crate::algorithms::visualization::to_image::ToImage;
use crate::boolean_formulae::clause::Clause;
use crate::boolean_formulae::data::Sample;
use crate::boolean_formulae::dnf::DNF;

mod regularizer;
mod neighbourhood_generator;
mod state;
pub mod run_config;
mod algorithms;

/// A basic hill climber
///
/// # Panics
pub fn basic_hill_climber<const DATA_DIM: usize>(run_config: &RunConfig<DATA_DIM>)
where
	BitsImpl<DATA_DIM>: Bits,
	<BitsImpl<{ DATA_DIM }> as Bits>::Store: Hash,
{
	debug!("Starting local search with config {:?}", run_config);

	let output_path = Path::new("output");
	let metrics_path = output_path.join("metrics");
	create_dir_all(&metrics_path).expect("Could not create output directory.");
	let mut output_file = File::create(&output_path.join("output")).expect("Could not create output file.");
	let mut metrics_file =
		File::create(&metrics_path.join("metrics")).expect("Could not create metrics file.");

	let data_file =
		File::open(Path::new(&run_config.data_path)).expect("Could not open the data file you provided.");
	let (positive_samples, negative_samples): (Vec<Sample<DATA_DIM>>, Vec<Sample<DATA_DIM>>) =
		BufReader::new(data_file)
			.lines()
			.filter_map(Result::ok)
			.filter_map(|line| serde_json::from_str(&line).ok())
			.partition(Sample::label);

	let positive_dnf = DNF::new(positive_samples.par_iter().map(Clause::from).collect());
	let negative_dnf = DNF::new(negative_samples.par_iter().map(Clause::from).collect());

	let initial_state: State<DATA_DIM> = State {
		positive_dnf,
		negative_dnf,
	};
	let mut best_state = initial_state.clone();

	let regularizer = run_config.regularizer;
	let neighbourhood_generators = run_config.neighbourhood_generators.clone();
	let algorithm = run_config.algorithm;

	if let Some(_metrics) = &run_config.metrics {
		save_metrics(&initial_state, &mut metrics_file, regularizer, "0");
		generate_pictures(&initial_state, &metrics_path, "0");
	}

	let mut algorithm_runner = AlgorithmRunner::new(
		algorithm,
		initial_state,
		positive_samples,
		negative_samples,
		neighbourhood_generators,
		regularizer,
	);

	while let Some(current_state) = algorithm_runner.step() {
		info!("In Iteration {}", algorithm_runner.iteration());
		if let Some(metrics) = &run_config.metrics {
			let iteration = algorithm_runner.iteration();
			if iteration % metrics.regularizer_frequency == 0 {
				save_metrics(
					&current_state,
					&mut metrics_file,
					regularizer,
					iteration.to_string().as_str(),
				);
			}
			if iteration % metrics.picture_frequency == 0 {
				generate_pictures(&current_state, &metrics_path, iteration.to_string().as_str());
			}
		}

		if regularizer.regularize(&current_state) < regularizer.regularize(&best_state) {
			best_state = current_state.clone();
		}
	}

	if let Some(_metrics) = &run_config.metrics {
		save_metrics(&best_state, &mut metrics_file, regularizer, "final");
		generate_pictures(&best_state, &metrics_path, "final");
	}

	output_file
		.write_all(
			format!(
				"Positive DNF: {}\n Negative DNF: {}",
				serde_json::to_string(&best_state.positive_dnf).unwrap(),
				serde_json::to_string(&best_state.negative_dnf).unwrap()
			)
			.as_bytes(),
		)
		.expect("Could not write final DNFs to output file.");
}

/// Creates Visualizations of the current state and saves them under the provided path
/// with filenames distinguished by the current iteration.
fn generate_pictures<const SIZE: usize>(state: &State<SIZE>, path: &Path, label: &str)
where
	BitsImpl<SIZE>: Bits,
	<BitsImpl<{ SIZE }> as Bits>::Store: Hash,
{
	state
		.positive_dnf
		.to_image(28, 28)
		.unwrap()
		.save(path.join(format!("iteration-{}-positive.png", label).as_str()))
		.unwrap();
	state
		.negative_dnf
		.to_image(28, 28)
		.unwrap()
		.save(path.join(format!("iteration-{}-negative.png", label).as_str()))
		.unwrap();
}

/// Writes metrics generated by the regularizer to the metrics file.
fn save_metrics<const SIZE: usize>(
	state: &State<SIZE>,
	metrics_file: &mut File,
	regularizer: Regularizer,
	label: &str,
) where
	BitsImpl<SIZE>: Bits,
	<BitsImpl<{ SIZE }> as Bits>::Store: Hash,
{
	metrics_file
		.write_all(
			format!(
				"Iteration: {}: DNF-regularizer value: {}\n",
				label,
				regularizer.regularize(state),
			)
			.as_bytes(),
		)
		.expect("Could not write to the metrics file.");
}
